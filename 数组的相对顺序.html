<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 给你两个数组，arr1 和 arr2，

  arr2 中的元素各不相同
  arr2 中的每个元素都出现在 arr1 中
  对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。
  未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。


  示例：

  输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
  输出：[2,2,2,1,4,3,3,9,6,7,19]

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/relative-sort-array
  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <script>
    var relativeSortArray = function (arr1, arr2) {
      const counts = new Array(1001).fill(0);

      for (const n of arr1) { // 统计arr1数字的出现次数
        counts[n]++;
      }

      const res = [];
      for (const n of arr2) {   // 遍历arr2
        while (counts[n] > 0) { // 出现次数>0，循环推入res
          res.push(n);	   // 循环结束时，值变为0
          counts[n]--;
        }
      }

      for (let i = 0; i < counts.length; i++) { // 遍历counts
        while (counts[i] > 0) { // 非0项的索引 循环推入res
          res.push(i);
          counts[i]--;
        }
      }
      return res;
    };

    // 作者：xiao_ben_zhu
    // 链接：https://leetcode-cn.com/problems/relative-sort-array/solution/bu-shi-yong-sort-pai-xu-de-jie-fa-1122-shu-zu-de-x/

    var relative2 = (arr1, arr2) => {
      const counts = new Array(1001).fill(0)
      for (const n of arr1) {
        counts[n]++
      }
      const res = []
      for (const n of arr2) {
        while (counts[n] > 0) {
          res.push(n)
          counts[n]--
        }
      }
      for (let i = 0; i < counts.length; i++) {
        while (counts[i] > 0) {
          res.push(i)
          counts[i]--
        }
      }
      return res
    }

    // 09-12复习
  </script>
</body>

</html>