<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 
    给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

    

    示例 1：

    输入：s = "(()"
    输出：2
    解释：最长有效括号子串是 "()"
    示例 2：

    输入：s = ")()())"
    输出：4
    解释：最长有效括号子串是 "()()"
    示例 3：

    输入：s = ""
    输出：0 -->
  <script>
    const longestValidParentheses = (s) => {
      let maxLen = 0;
      const stack = [];
      stack.push(-1);
      for (let i = 0; i < s.length; i++) {
        const c = s[i];
        if (c == '(') {       // 左括号的索引，入栈
          stack.push(i);
        } else {              // 遍历到右括号
          stack.pop();        // 栈顶的左括号被匹配，出栈
          if (stack.length) { // 栈未空
            const curMaxLen = i - stack[stack.length - 1]; // 计算有效连续长度
            maxLen = Math.max(maxLen, curMaxLen);          // 挑战最大值
          } else {            // 栈空了
            stack.push(i);    // 入栈充当参照
          }
        }
      }
      return maxLen;
    };

    // 见链接图解：
    // 作者：xiao_ben_zhu
    // 链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/shou-hua-tu-jie-zhan-de-xiang-xi-si-lu-by-hyj8/


    var longestP2 = (s) => {
      let max = 0
      const stack = []
      stack.push(-1)
      for (let i = 0; i < s.length; i++) {
        const c = s[i]
        if (c == '(') {
          stack.push(i)
        } else {
          stack.pop()
          if (stack.length) {
            const curMax = i - stack[stack.length - 1]
            max = Math.max(curMax, max)
          } else {
            stack.push(i)
          }
        }
      }
      return max
    }

    // 09-29复习
  </script>
</body>

</html>