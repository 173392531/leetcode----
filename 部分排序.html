<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。

  示例：

  输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
  输出： [3,9]

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/sub-sort-lcci
  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <!-- 题目数组都是单调递增的
  当一个数a[i]左侧有一个数比它大的时候，或者右侧有一个数比它小的时候，它一定是在被排序的序列内。
  因为一个数如果 左边的数都比它小，右边的数都比它大，显然没必要排序。
  关键是我们如何找出

  <1>最右侧一个a[i]，它的左边含有一个大于它的数
  <2>最左侧一个a[i]，它的右边含有一个小于它的数
  我们这里可以使用两次遍历，分别从左往右找<1>，从右往左找<2>。

  记录当前遍历序列的最大值MAX，如果有一个数比它小，那么记录这个数的index，遍历完成后，这个index即是<1>
  记录当前遍历序列的最小值MIN，如果有一个数比它大，那么记录这个数的index，遍历完成后，这个index即使<2> -->
  <script>
    /**
 * @param {number[]} array
 * @return {number[]}
 */
    var subSort = function (array) {
      let r = -1, l = -1;
      //正向遍历记录最右区间值
      let max = Number.MIN_SAFE_INTEGER;
      // console.log(max);
      for (let i = 0; i < array.length; i++) {
        if (array[i] >= max) {
          max = array[i];
        } else {
          r = i;
          console.log('r', r);

        }
      }
      //反向遍历记录最左区间值
      let min = Number.MAX_SAFE_INTEGER;
      // console.log(min);
      for (let i = array.length - 1; i >= 0; i--) {
        if (array[i] <= min) {
          min = array[i]
        } else {
          l = i;
          console.log('l', l);

        }
      }
      return [l, r]
    };
    console.log(subSort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]));
    // 作者：lee-lei
    // 链接：https://leetcode-cn.com/problems/sub-sort-lcci/solution/zheng-fan-liang-ci-bian-li-by-lee-lei/
    var subSort = (arr) => {
      let r = -1, l = -1;
      let max = Number.MIN_SAFE_INTEGER
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] >= max) {
          max = arr[i]
        } else {
          r = i
        }
      }
      let min = Number.MAX_SAFE_INTEGER
      for (let i = arr.length - 1; i > 0; i--) {
        if (arr[i] <= min) {
          min = arr[i]
        } else {
          l = i
        }
      }
      return [l, r]
    }
    // 双向遍历找出不符合规律的边界指针
    // 08-03复习
  </script>
</body>

</html>