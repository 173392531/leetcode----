<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：

    words.length == indices.length,助记字符串 s 以 '#' 字符结尾
    对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 '#' 字符结束（但不包括 '#'）的 子字符串 恰好与 words[i] 相等
    给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。

     
    示例 1：

    输入：words = ["time", "me", "bell"]
    输出：10
    解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。
    words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
    words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
    words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
    示例 2：

    输入：words = ["t"]
    输出：2
    解释：一组有效编码为 s = "t#" 和 indices = [0] 。

    链接：https://leetcode-cn.com/problems/short-encoding-of-words -->
    <script>
        var minimumLengthEncoding = function (words) {
            let hashSet = new Set(words);
            for (let item of hashSet) {
                for (let i = 1; i < item.length; i++) {
                    // 切片，看看是否词尾在 hashSet 中，切片从1开始，只看每个单词的词尾
                    let target = item.slice(i);
                    hashSet.has(target) && hashSet.delete(target);
                }
            }
            let result = 0;
            // 根据 hashSet 中剩余元素计算最终长度
            hashSet.forEach(item => result += item.length + 1)
            return result
        };
// 作者：chenwenwu
// 链接：https://leetcode-cn.com/problems/short-encoding-of-words/solution/javascriptjs-jian-dan-ti-jie-by-chenwenwu-2/
    </script>
</body>

</html>