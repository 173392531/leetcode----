<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
 

示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <script>
    // 如果p和q分别是root的左右节点，那么root就是我们要找的最近公共祖先
    // 如果root是None，说明我们在这条寻址线路没有找到，我们返回None表示没找到
    // 我们继续在左右子树执行相同的逻辑。
    // 如果左子树没找到，说明在右子树，我们返回lowestCommonAncestor(root.right, p , q)
    // 如果右子树没找到，说明在左子树，我们返回lowestCommonAncestor(root.left, p , q)
    // 如果左子树和右子树分别找到一个，我们返回root

    var lowestCommonAncestor = function (root, p, q) {
      if (!root || root === p || root === q) return root;
      const left = lowestCommonAncestor(root.left, p, q);
      const right = lowestCommonAncestor(root.right, p, q);
      if (!left) return right; // 左子树找不到，返回右子树
      if (!right) return left; // 右子树找不到，返回左子树
      return root;//左右子树都能找到，返回当前的根节点
    };

    // 作者：fe - lucifer
    // 链接：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/chao-jian-dan-di-gui-pythonjavascript-by-azl397985/


    var lowC = (root, p, q) => {
      if (!root || root == p || root == q) return root
      const left = lowC(root.left, p, q)
      const right = lowC(root.right, p, q)
      if (!left) return right
      if (!right) return left
      return root
    }

    var lowCc = (root, p, q) => {
      if (!root || root == p || root == q) return root
      const left = lowCc(root.left, p, q)
      const right = lowCc(root.right, p, q)
      if (!left) return right
      if (!right) return left
      return root
    }

    var lowCC = (root, p, q) => {
      if (!root || root == p || root == q) return root
      const left = lowCC(root.left, p, q)
      const right = lowCC(root.right, p, q)
      // 当左右树中有一方没有查到子节点时，返回另一方的查询结果
      if (!left) return right
      if (!right) return left
      //  只有当左树右树都有才返回root，这就是它们的最近祖先
      return root
    }


    // var ss=(arr)=>{
    //   if(arr.length){
    //     console.log(arr);
    //     arr.pop()
    //   }else{
    //     return
    //   }
    //   const left=ss(arr)
    // }
    // console.log(ss([1,2,3,4,5,6,7,8]));

  </script>
</body>

</html>