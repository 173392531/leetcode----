<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 给你 root1 和 root2 这两棵二叉搜索树。
        请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.

        示例 1：

        输入：root1 = [2,1,4], root2 = [1,0,3]
        输出：[0,1,1,2,3,4]
        示例 2：

        输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]
        输出：[-10,0,0,1,2,5,7,10]
        示例 3：

        输入：root1 = [], root2 = [5,1,7,0,2]
        输出：[0,1,2,5,7]
        示例 4：

        输入：root1 = [0,-10,10], root2 = []
        输出：[-10,0,10]
        示例 5：

        输入：root1 = [1,null,8], root2 = [8,1]
        输出：[1,1,8,8]

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
    <script>
        const getAllElements = (root1, root2) => {
            const arr1 = [];
            const arr2 = [];
            traversal(root1, arr1);
            traversal(root2, arr2);
            const ret = [];
            let idx1 = idx2 = 0;
            while (idx1 < arr1.length && idx2 < arr2.length) {
                arr1[idx1] < arr2[idx2] ? ret.push(arr1[idx1++]) : ret.push(arr2[idx2++]);
            }
            // 某一方数组全部被加入到ret之后
            while (idx1 < arr1.length) ret.push(arr1[idx1++]);
            while (idx2 < arr2.length) ret.push(arr2[idx2++]);
            return ret;

            function traversal(node, arr) {
                if (!node) return;
                traversal(node.left, arr);
                arr.push(node.val);
                traversal(node.right, arr);
            }
        };

        // 作者：poppinl
        // 链接：https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/solution/bao-bao-ye-neng-kan-dong-de-leetcode-ti-jie-inorde/

    </script>
</body>

</html>