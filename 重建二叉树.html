<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

  例如，给出

  前序遍历 preorder = [3,9,20,15,7]
  中序遍历 inorder = [9,3,15,20,7]
  返回如下的二叉树：

      3
    / \
    9  20
      /  \
    15   7

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof
  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <script>
    /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */
    /**
     * @param {number[]} preorder
     * @param {number[]} inorder
     * @return {TreeNode}
     */
    function TreeNode(val) {
      this.val = val;
      this.left = this.right = null;
    }
    var buildTree = function (preorder, inorder) {
      debugger
      if (!preorder.length || !inorder.length) return null
      let root = preorder[0]; // 前序遍历的第一个元素为根节点
      let node = new TreeNode(root); // 确定根节点

      let i = inorder.indexOf(root); // 获取根节点在中序遍历中的位置(用于分割左右子树)

      // 递归
      node.left = buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));
      node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
      return node
    };
    console.log(buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7]));


    var buildTree2 = (preorder, inorder) => {
      if (!preorder.length || !inorder.length) return null
      let root = preorder[0]
      let node = new TreeNode(root)
      let i = inorder.indexOf(root)
      node.left = buildTree2(preorder.slice(1, i + 1), inorder.slice(0, i))
      node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
      return node
    }

    // 作者：chenwenwu
    // 链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/javascriptjs-di-gui-ti-jie-by-lucode/

    var buildT3 = (pre, ino) => {
      if (!pre.length || !ino.length) return null
      let root = pre[0], node = new TreeNode(root), i = ino.indexOf(root)
      node.left = buildT3(pre.slice(1, i + 1), ino.slice(0, i))
      node.right = buildT3(pre.slice(i + 1), ino.slice(i + 1))
      return node
    }
  </script>
</body>

</html>