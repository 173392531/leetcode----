<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 给定一个二叉树的根节点 root ，返回它的 中序 遍历。

        示例 1：


        输入：root = [1,null,2,3]
        输出：[1,3,2]
        示例 2：

        输入：root = []
        输出：[]    -->
    <script>
        const inorderTraversal = (root) => {
            const res = [];
            const stack = [];

            while (root) {        // 能压入栈的左子节点都压进来
                stack.push(root);
                root = root.left;
            }
            while (stack.length) {
                let node = stack.pop(); // 栈顶的节点出栈
                res.push(node.val);     // 在压入右子树之前，处理它的数值部分（因为中序遍历）
                node = node.right;      // 获取它的右子树
                while (node) {          // 右子树存在，执行while循环    
                    stack.push(node);     // 压入当前root
                    node = node.left;     // 不断压入左子节点
                }
            }
            return res;
        };

        // 作者：xiao_ben_zhu
        // 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/
        const inT = (root) => {
            const res = []
            const stack = [];
            while (root) {
                stack.push(root)
                root = root.left
            }
            while (stack.length) {
                let node = stack.pop()
                res.push(node.val)
                node = node.right
                while (node) {
                    stack.push(node)
                    node = node.left
                }
            }
            return res
        }

        var init = (root) => {
            const res = [], stack = []
            while (root) {
                stack.push(root)
                root = root.left
            }
            while (stack.length) {

            }
        }

        // 中序遍历实质上就是获取树在水平轴上的投影
        const inorderTraversal = (root) => {
            const res = [];
            const stack = [];

            while (root) {        // 能压入栈的左子节点都压进来
                stack.push(root);
                root = root.left;
            }
            while (stack.length) {
                let node = stack.pop(); // 栈顶的节点出栈
                res.push(node.val);     // 在压入右子树之前，处理它的数值部分（因为中序遍历）
                node = node.right;      // 获取它的右子树
                while (node) {          // 右子树存在，执行while循环    
                    stack.push(node);     // 压入当前root
                    node = node.left;     // 不断压入左子节点
                }
            }
            return res;
        };

        const iT = (root) => {
            const res = [], stack = []
            while (root) {
                stack.push(root)
                root = root.left
            }
            while (stack.length) {
                let node = stack.pop()
                res.push(node.val)
                node = node.right
                while (node) {
                    stack.push(node)
                    node = node.left
                }
            }
            return res
        }

        // 作者：xiao_ben_zhu
        // 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/



        var middleTree=(root)=>{
            const res=[],stack=[]
            while(root){
                stack.push(root)
                root=root.left
            }
            while(stack.length){
                let node=stack.pop()
                res.push(node.val)
                node=node.right
                while(node){
                    stack.push(node)
                    node=node.left
                }
            }
            return res
        }

        var mid=(root)=>{
            const res=[],stack=[]
            while(root){
                stack.push(root)
                root=root.left
            }
            while(stack.length){
                let node=stack.pop()
                res.push(node.val)
                node=node.right
                while(node){
                    stack.push(node)
                    node=node.left
                }
            }
            return res
        }

        var mmd=(root)=>{
            const res=[],stack=[]
            while(root){
                stack.push(root)
                root=root.left
            }
            while(stack.length){
                let node=stack.pop()
                arr.push(node.val)
                node=node.right
                while(node){
                    stack.push(node)
                    node=node.left                    
                }
            }
            return res
        }
        // 08-10复习
    </script>
</body>

</html>