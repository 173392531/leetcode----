<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

  示例 1：

  输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
  输出：true
  解释：我们可以按以下顺序执行：
  push(1), push(2), push(3), push(4), pop() -> 4,
  push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
  示例 2：

  输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
  输出：false
  解释：1 不能在 2 之前弹出。

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof
  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <script>
    var validateStackSequences = function (pushed, popped) {
      //辅助栈
      const stack = [];
      //指向poped当前的下标
      let index = 0;
      //把pushed的元素一个一个入栈
      for (let i = 0, len = pushed.length - 1; i <= len; i++) {
        stack.push(pushed[i])
        //把入栈的当前元素和pushed当前指向的元素进行对比
        //相等话就把辅助栈出栈
        //pushed下标往右移动
        while (stack.length !== 0 && stack[stack.length - 1] === popped[index]) {
          stack.pop()
          index++
        }
      }
      //如果stack为空，说明符合题目
      return !stack.length
    };

// 作者：qing-jiao-wo-xiao-bai-tong-xue
// 链接：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/fu-zhu-zhan-by-qing-jiao-wo-xiao-bai-tong-xue/

var myStack=function(pushed,popped){
  let stack=[],index=0
  for(let i=0;i<pushed.length;i++){
    stack.push(pushed[i])
    while(stack.length && stack[stack.length-1]==popped[index]){
      stack.pop()
      index++
    }
  }
  return !stack.length
}
  </script>
</body>

</html>