<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 给你一个整数数组 nums ，数组中共有 n 个整数。
    132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，
    并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。
    如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

  进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？

 

  示例 1：

  输入：nums = [1,2,3,4]
  输出：false
  解释：序列中不存在 132 模式的子序列。
  示例 2：

  输入：nums = [3,1,4,2]
  输出：true
  解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
  示例 3：

  输入：nums = [-1,3,2,0]
  输出：true
  解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/132-pattern
  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <!-- 132模式至少存在三个数字 分别为 min， max， med
    min， max， med 顺序不可调换
    遍历数组找 med 的位置
    如果当前遍历大于栈顶元素 则栈的单调性被破坏，清空栈 将当前值压入栈底 将栈底元素作为med
    如果 med max 都存在 遍历到 比med小的值 可放入min位置 返回true

    作者：zn_
    链接：https://leetcode-cn.com/problems/132-pattern/solution/dan-diao-zhan-jie-132-by-zn_-s8xh/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->
  <script>
    var find132pattern = function (nums) {
      let stack = [], med = -Infinity
      for (let i = nums.length - 1; i >= 0; i--) {
        if (nums[i] < med) return true
        while (stack.length > 0 && stack[stack.length - 1] < nums[i]) {
          mid = stack.pop()
        }
        stack.push(nums[i])
      }
      return false
    };

    var find132=(nums)=>{
      let stack=[],mid=-Infinity
      for(let i=nums.length-1;i>=0;i--){
        if(nums[i]<mid)return true
        while(stack.length>0 && stack[stack.length-1]<nums[i]){
          mid=stack.pop()
        }
        stack.push(nums[i])
      }
    }

    // 作者：zn_
    // 链接：https://leetcode-cn.com/problems/132-pattern/solution/dan-diao-zhan-jie-132-by-zn_-s8xh/

    var find132pattern = function (nums) {
      let minIdx = 0, len = nums.length, stack = [];
      while (minIdx < len) {
        stack = [];
        for (let i = minIdx; i < len; i++) {
          if (!stack.length) stack[0] = nums[i];
          if (nums[i] > stack[0] && stack.length === 1) stack[1] = nums[i];
          if (nums[i] > stack[1] && stack.length === 2 && i !== len - 1) stack[1] = nums[i];
          if (nums[i] > stack[0] && nums[i] < stack[1]) return true;
          if (minIdx === len - 2) return false;
        }
        minIdx++;
      }
      return false;
    };

    // 作者：demigodliu
    // 链接：https://leetcode-cn.com/problems/132-pattern/solution/zhan-132mo-shi-by-demigodliu-v9cx/

    // 07-31复习
    // 10-03
  </script>
</body>

</html>