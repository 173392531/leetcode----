<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-path-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->

  <!-- 核心思路：
    1、DP方程
    当前项最小路径和 = 当前项值 + 上项或左项中的最小值
    grid[i][j] += Math.min( grid[i - 1][j], grid[i][j - 1] )

    2、边界处理
    grid的第一行与第一列 分别没有上项与左项 故单独处理计算起项最小路径和
    计算第一行

    作者：floretpig
    链接：https://leetcode-cn.com/problems/minimum-path-sum/solution/dong-tai-gui-hua-jian-ji-shi-xian-by-floretpig/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->
  <script>
  /**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
      let row = grid.length, col = grid[0].length

      // calc boundary
      for(let i = 1; i < row; i++)
          // calc first col
          grid[i][0] += grid[i - 1][0]

      for(let j = 1; j < col; j++)
          // calc first row
          grid[0][j] += grid[0][j - 1]

      for(let i = 1; i < row; i++)
          for(let j = 1; j < col; j++)
              grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1])
      
      return grid[row - 1][col - 1]
  };
  var x=minPathSum([[991,993,996],[994,995,997],[0,998,999]])
  console.log(x);
  </script>
</body>
</html>