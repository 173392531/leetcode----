<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。
        给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。

        示例：
        给定如下二叉树

             2
            / \
           1   3
        返回：

        [
        [2,1,3],
        [2,3,1]
        ]

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/bst-sequences-lcci
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
    <script>
        let root={
            val:13,
            left:{
                val:8,
                left:6,
            }, 
            right:{
                val:16,
                right:18
            }
        }
        var BSTSequences = function (root) {
            let res = []
            if (root == null) return [[]]
            let quenue = []

            let dfs = (root, res, quenue, temp) => {
                if (root == null) return
                if (root.left) quenue.push(root.left)
                if (root.right) quenue.push(root.right)
                if (quenue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = quenue
                while (length--) {
                    let cur = quenue.shift()
                    dfs(cur, res, quenue.slice(), [...temp, cur.val])
                    quenue.push(cur)
                }
            }

            dfs(root, res, quenue, [root.val])
            return res
        };
        console.log(BSTSequences(root))
// 作者：sc8816
// 链接：https://leetcode-cn.com/problems/bst-sequences-lcci/solution/dfs-by-sc8816/


    </script>
</body>

</html>