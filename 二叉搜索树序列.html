<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。
        给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。

        示例：
        给定如下二叉树

             2
            / \
           1   3
        返回：

        [
        [2,1,3],
        [2,3,1]
        ]

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/bst-sequences-lcci
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
    <script>
        let root = {
            val: 13,
            left: {
                val: 8,
                left: 6,
            },
            right: {
                val: 16,
                right: 18
            }
        }
        var BSTSequences = function (root) {
            debugger
            let res = []
            if (root == null) return [[]]
            let quenue = []

            let dfs = (root, res, quenue, temp) => {
                if (root == null) return
                if (root.left) quenue.push(root.left)
                if (root.right) quenue.push(root.right)
                if (quenue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = quenue
                console.log(length);
                while (length--) {
                    let cur = quenue.shift()
                    console.log(cur);
                    dfs(cur, res, quenue.slice(), [...temp, cur.val])
                    quenue.push(cur)
                }
            }

            dfs(root, res, quenue, [root.val])
            return res
        };
        // console.log(BSTSequences(root))


        var BST = (root) => {

            let res = []
            if (root == null) return [[]]
            let queue = []

            let dfs = (root, res, queue, temp) => {
                if (root == null) return
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp, cur.val])
                    queue.push(cur)
                }
            }
            dfs(root, res, queue, [root.val])
            return res
        }


        function TreeNode(val) {
            this.val = val;
            this.left = this.right = null;
        }
        const createTree = (arr) => { // 创建二叉树
            let tree = new TreeNode(arr[0])
            let Nodes = [tree]
            let i = 1
            for (let node of Nodes) {
                node.left = new TreeNode(arr[i])
                Nodes.push(node.left)
                i += 1
                if (i == arr.length) return tree
                node.right = new TreeNode(arr[i])
                Nodes.push(node.right)
                i += 1
                if (i == arr.length) return tree
            }
        }
        console.log(BSTSequences(createTree([4, 2, 6, 1, 3])));



        var BBST = (root) => {
            let res = []
            if (root == null) return [[]]
            let queue = []
            let dfs = (root, res, queue, temp) => {
                if (root == null) return
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp, cur.val])
                    queue.push(cur)
                }
            }
            dfs(root, res, queue, [root.val])
            return res
        }

        var B = (root) => {
            let res = []
            if (root == null) return [[]]
            let queue = []
            let dfs = (root, res, queue, temp) => {
                if (root == null) return
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp])
                    queue.push(cur)
                }
            }
            dfs(root, res, queue, [root.val])
            return res
        }

        var Bst = (root) => {
            let res = []
            if (root == null) return [[]]
            let queue = []
            let dfs = (root, res, queue, temp) => {
                if (root == null) return
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp])
                    queue.push(cur)
                }
            }
            dfs(root, res, queue, [root.val])
            return res
        }

        var bst = (root) => {
            let res = [], queue = []
            if (root == null) return [[]]
            let dfs = (root, res, queue, temp) => {
                // 条件拦截
                if (root == null) return
                // 收集依赖
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                // 终止条件
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                // 依赖处理
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp, cur.val])
                    queue.push(cur)
                }
            }
        }

        var bst3 = (root) => {
            let res = [], queue = []
            if (!root) return [[]]
            var dfs = (root, res, queue, temp) => {
                if (!root) return
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp, cur.val])
                    queue.push(cur)
                }
            }
        }

        // var bst4=(root)=>{

        // }
        let ques = [1, 2, 3, 4]
        ques.shift()
        ques.slice().shift()
        console.log(ques);


        var bst4 = (root) => {
            if (!root) return
            let res = [], queue = []
            var dfs = (root, res, queue, temp) => {
                if (!root) return
                if (root.left) queue.push(root.left)
                if (root.right) queue.push(root.right)
                if (queue.length == 0) {
                    res.push([...temp])
                    return
                }
                let { length } = queue
                while (length--) {
                    let cur = queue.shift()
                    dfs(cur, res, queue.slice(), [...temp, cur.val])
                    queue.push(cur)
                }
            }
            dfs(root, res, queue, [])
            return res
        }
        // 作者：sc8816
        // 链接：https://leetcode-cn.com/problems/bst-sequences-lcci/solution/dfs-by-sc8816/

        // 08-11复习

        var bst5=(root)=>{
            if(!root)return 
            let res=[],queue=[]
            var dfs=(root,res,queue,temp)=>{
                if(!root)return 
                if(root.left)queue.push(root.left)
                if(root.right)queue.push(root.right)
                if(queue.length==0){
                    res.push([...temp])
                    return 
                }
                let {length}=queue
                while(length--){
                    let cur =queue.shift()
                    dfs(cur,res,queue.slice(),[...temp,cur.val])
                    queue.push(cur)
                }
            }
            dfs(root,res,queue,[])
            return res
        }

    var bfs=(root)=>{
        const res=[],queue=[]
        const dfs=(root,res,queue,temp)=>{
            if(root===null)return 
            root.left && queue.push(root.left)
            root.right && queue.push(root.right)
            if(queue.length == 0){
                res.push([...temp])
                return
            }
            let len=queue.length
            while(len){
                len--
                let cur=queue.shift()
                dfs(cur,res,queue.slice(),[...temp,cur.val])
                queue.push(cur)
            }
            dfs(root,res,queue,[root.val])
            return res
        }
    }
    </script>
</body>

</html>