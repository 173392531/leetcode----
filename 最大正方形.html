<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 在一个由 '0' 和 '1' 组成的二维矩阵内，
    找到只包含 '1' 的最大正方形，并返回其面积。 -->

  <!-- 输入：matrix = [
      ["1","0","1","0","0"],
      ["1","0","1","1","1"],
      ["1","1","1","1","1"],
      ["1","0","0","1","0"]
      ]
    输出：4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximal-square
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <script>
    /*
 * @lc app=leetcode id=221 lang=javascript
 *
 * [221] Maximal Square
 */
    /**
     * @param {character[][]} matrix
     * @return {number}
     */
    var maximalSquare = function (matrix) {
      if (matrix.length === 0) return 0;
      const dp = [];
      const rows = matrix.length;
      const cols = matrix[0].length;
      let max = Number.MIN_VALUE;

      // 给矩阵镀个边使之在i=1的情况下也能i-1也能算出值来
      for (let i = 0; i < rows + 1; i++) {
        if (i === 0) {
          dp[i] = Array(cols + 1).fill(0);
        } else {
          dp[i] = [0];
        }
      }

      for (let i = 1; i < rows + 1; i++) {
        for (let j = 1; j < cols + 1; j++) {
          if (matrix[i - 1][j - 1] === "1") {
            dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
            max = Math.max(max, dp[i][j]);
          } else {
            dp[i][j] = 0;
          }
        }
      }
      return max * max;
    };

    // 作者：fe-lucifer
    // 链接：https://leetcode-cn.com/problems/maximal-square/solution/dong-tai-gui-hua-han-kong-jian-you-hua-221-zui-da-/


    var maxS2 = (matrix) => {
      if (matrix.length === 0) return 0
      const dp = []
      const rows = matrix.length
      const cols = matrix[0].length
      let max = Number.MIN_SAFE_INTEGER
      for (let i = 0; i < rows; i++) {
        if (i == 0) {
          dp[i] = Array(cols + 1).fill(0)
        } else {
          dp[i] = 0
        }
      }
      for (let i = 1; i < rows + 1; i++) {
        for (let j = 1; j < cols + 1; j++) {
          if (matrix[i - 1][j - 1] === '1') {
            dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
            max = Math.max(max, dp[i][j])
          } else {
            dp[i][j] = 0
          }
        }
      }
      return max * max
    }

    // 09-27复习
  </script>
</body>

</html>