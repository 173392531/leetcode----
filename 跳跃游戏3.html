<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。
        当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。
        请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。
        注意，不管是什么情况下，你都无法跳到数组之外。
         
        示例 1：

        输入：arr = [4,2,3,0,3,1,2], start = 5
        输出：true
        解释：
        到达值为 0 的下标 3 有以下可能方案： 
        下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
        下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 
        示例 2：

        输入：arr = [4,2,3,0,3,1,2], start = 0
        输出：true 
        解释：
        到达值为 0 的下标 3 有以下可能方案： 
        下标 0 -> 下标 4 -> 下标 1 -> 下标 3
        示例 3：

        输入：arr = [3,0,2,1,2], start = 2
        输出：false
        解释：无法到达值为 0 的下标 1 处。

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/jump-game-iii
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
    <script>
        // bfs

        // 这里算是一个非常常见的广度优先遍历的实现模板了，不过具体到这道题其实还可以再优化一下。
        // 我们可以注意到题目的限制条件里，arr 的每个值取值范围是 [0, arr.length]。
        // 基于此，我们可以通过赋值为一个范围外的特殊值来标识已经访问过，从而去掉 visited 集合的使用。
        // 我这里直接使用了 -1 作为特殊值，具体代码如下：

        const canReach = (arr, start) => {
            const visited = new Set();
            const queue = [start];
            for (let len = 0, max = arr.length; len < queue.length; ++len) {
                const idx = queue[len];
                if (visited.has(idx)) continue;
                if (arr[idx] === 0) return true;
                visited.add(idx);
                idx + arr[idx] < max && queue.push(idx + arr[idx]);
                idx - arr[idx] >= 0 && queue.push(idx - arr[idx]);
            }
            return false;
        };

        var canR2 = (arr, start) => {
            const visited = new Set()
            const queue = [start]
            for (let len = 0, max = arr.length; len < queue.length; len++) {
                const idx = queue[len]
                if (visited.has(idx)) continue
                if (arr[idx] === 0) return true
                visited.add(idx)
                idx + arr[idx] < max && queue.push(idx + arr[idx])
                idx - arr[idx] >= 0 && queue.push(idx - arr[idx])
            }
            return false
        }

        var canR3 = (arr, start) => {
            const visited = new Set()
            const queue = [start]
            for (let len = 0, max = arr.length; len < queue.length; len++) {
                const idx = queue[len]
                if (visited.has(idx)) continue
                if (arr[idx] === 0) return true
                visited.add(idx)
                idx + arr[idx] < max && queue.push(idx + arr[idx])
                idx - arr[idx] >= 0 && queue.push(idx - arr[idx])
            }
            return false
        }

        var canR4 = (arr, start) => {
            const visited = new Set()
            const queue = [start]
            for (let len = 0, max = arr.length; len < queue.length; len++) {
                const idx = queue[len]
                if (visited.has(idx)) continue
                if (arr[idx] === 0) return true
                visited.add(idx)
                idx + arr[idx] < max && queue.push(idx + arr[idx])
                idx - arr[idx] >= 0 && queue.push(idx - arr[idx])
            }
            return false
        }
        // 作者：poppinl
        // 链接：https://leetcode-cn.com/problems/jump-game-iii/solution/bao-bao-ye-neng-kan-dong-de-leetcode-ti-jie-bfs-df/

        // dfs
        const canReach = (arr, start) => {
            const val = arr[start];
            if (val === 0) return true;
            if (val === -1) return false;
            arr[start] = -1;
            return (start - val >= 0 && canReach(arr, start - val)) || (start + val < arr.length && canReach(arr, start + val));
        };

        // 作者：poppinl
        // 链接：https://leetcode-cn.com/problems/jump-game-iii/solution/bao-bao-ye-neng-kan-dong-de-leetcode-ti-jie-bfs-df/


        var canR2 = (arr, start) => {
            const val = arr[start]
            if (val === 0) return true
            if (val === -1) return false
            arr[start] = -1
            return (start - val >= 0 && canR2(arr, start - val)) || (start + val < arr.length && canR2(arr, start + val))
        }

        var canR3 = (arr, start) => {
            const val = arr[start]
            if (val === 0) return true
            if (val === -1) return false
            arr[start] = -1
            return (start - val >= 0 && canR3(arr, start - val)) || (start + val < arr.length && canR3(arr, start + val))
        }

        var canR4 = (arr, start) => {
            const val = arr[start]
            if (val === 0) return true
            if (val === -1) return false
            arr[start] = -1
            return (start - val >= 0 && canR4(arr, start - val)) || (start + val < arr.length && canR4(arr, start + val))
        }

        // 09-16复习
    </script>
</body>

</html>