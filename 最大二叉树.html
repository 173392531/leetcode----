<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    //     给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

    // 二叉树的根是数组 nums 中的最大元素。
    // 左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
    // 右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
    // 返回有给定数组 nums 构建的 最大二叉树 。

    // 示例：输入：nums = [3,2,1,6,0,5]
    // 输出：[6,3,5,null,2,0,null,null,1]
    // 解释：递归调用如下所示：
    // - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    //     - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
    //         - 空数组，无子节点。
    //         - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
    //             - 空数组，无子节点。
    //             - 只有一个元素，所以子节点是一个值为 1 的节点。
    //     - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
    //         - 只有一个元素，所以子节点是一个值为 0 的节点。
    //         - 空数组，无子节点。

    // 图片：https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg

    // 解题思路
    // 基础的递归题目

    // 当判断是递归题时
    // 1.递归的参数
    // 2.递归是否完全
    // 3.递归的临界值
    // 本题类似前面的前序中序求树一样
    // 找到最大值
    // 利用数组切割即可

    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {number[]} nums
     * @return {TreeNode}
     */
    var constructMaximumBinaryTree = function (nums) {
      if (nums.length == 0)
        return null
      var big = Math.max(...nums)
      var root = new TreeNode(big)
      root.left = constructMaximumBinaryTree(nums.slice(0, nums.indexOf(big)))
      root.right = constructMaximumBinaryTree(nums.slice(nums.indexOf(big) + 1))
      return root

      // 链接：https://leetcode-cn.com/problems/maximum-binary-tree/solution/di-gui-dai-ma-jian-ji-yi-dong-by-caifeng123/
    };

    var constM2=(nums)=>{
      if(nums.length==0)return null
      let big=Math.max(...nums)
      let root=new TreeNode(big)
      root.left=constM2(nums.slice(0,nums.indexOf(big)))
      root.right=constM2(nums.slice(nums.indexOf(big)+1))
      return root
    }

    var constM3=(nums)=>{
      if(nums.length==0)return null
      let big=Math.max(...nums)
      let root=new TreeNode(big)
      root.left=constM3(nums.slice(0,nums.indexOf(big)))
      root.right=constM3(nums.slice(nums.indexOf(big)+1))
    }
  </script>
</body>

</html>