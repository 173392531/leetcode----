<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

示例 1:

输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:

2
示例 2:

输入:

              1
             / \
            4   5
           / \   \
          4   4   5
输出:

2 
-->
  <!-- 递归函数是求一个子树可以向父节点提供的路径长度
对于当前节点，左子树能提供的长度为 left，如果当前节点值等于左子节点的值，则左链的长度等于left+1，否则为0
对于当前节点，右子树能提供的长度为right，如果当前节点值等于右子节点的值，则右链的长度等于right+1，否则为0
当前子树对父节点提供的最大长度为左右链中较大的一个
当前子树的左右链之和，去和全局最大值比较，试图更新它 -->
  <script>
    const longestUnivaluePath = (root) => {
      let res = 0

      const dfs = (root) => {
        if (root == null) {
          return 0
        }
        const left = dfs(root.left)
        const right = dfs(root.right)

        let leftPath = 0, rightPath = 0

        if (root.left && root.left.val == root.val) {
          leftPath = left + 1
        }
        if (root.right && root.right.val == root.val) {
          rightPath = right + 1
        }
        res = Math.max(res, leftPath + rightPath)

        return Math.max(rightPath, leftPath)
      }

      dfs(root)
      return res
    }

    // 作者：xiao_ben_zhu
    // 链接：https://leetcode-cn.com/problems/longest-univalue-path/solution/zui-chang-tong-zhi-lu-jing-by-hyj8/

    const longestU2 = (root) => {
      let res = 0
      const dfs = (root) => {
        if (root == null) return 0
        const left = dfs(root.left)
        const right = dfs(root.right)
        let leftPath = 0, rightPath = 0
        if (root.left && root.left.val == root.val) {
          leftPath = left + 1
        }
        if (root.right && root.right.val == root.val) {
          rightPath = right + 1
        }
        res = Math.max(res, leftPath + rightPath)
        return Math.max(rightPath, leftPath)
      }
      dfs(root)
      return res
    }

    const longestU3 = (root) => {
      let res = 0
      const dfs = (root) => {
        if (root === null) return 0
        const left = dfs(root.left)
        const right = dfs(root.right)
        let leftPath = 0, rightPath = 0
        if (root.left && root.left.val == root.val) {
          leftPath = left + 1
        }
        if (root.right && root.right.val == root.val) {
          rightPath = right + 1
        }
        res = Math.max(res, leftPath + rightPath)
        return Math.max(rightPath, leftPath)
      }
      dfs(root)
      return res
    }

    // 09-29复习

    const longC5=(root)=>{
      let res = 0
      const dfs= (root)=>{
        if(root===null)return 0
        const left = dfs(root.left)
        const right = dfs(root.right)
        const leftP =0,rightP =0
        if(root.left && root.left.val===root.val){
          leftP=left+1
        }
        if(root.right && root.right.val == root.val){
          rightP = right+1
        }
        res = Math.max(res,leftP+rightP)
        return Math.max(rightP,leftP)
      }
      dfs(root)
      return res
    }
  </script>
</body>

</html>