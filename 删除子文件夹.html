<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 你是一位系统管理员，手里有一份文件夹列表 folder，
        你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。
        我们这样定义「子文件夹」：
        如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的子文件夹。
        文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：
        / 后跟一个或者多个小写英文字母。
        例如，/leetcode 和 /leetcode/problems 都是有效的路径，而空字符串和 / 不是。
         
        示例 1：

        输入：folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
        输出：["/a","/c/d","/c/f"]
        解释："/a/b/" 是 "/a" 的子文件夹，而 "/c/d/e" 是 "/c/d" 的子文件夹。
        示例 2：

        输入：folder = ["/a","/a/b/c","/a/b/d"]
        输出：["/a"]
        解释：文件夹 "/a/b/c" 和 "/a/b/d/" 都会被删除，因为它们都是 "/a" 的子文件夹。
        示例 3：

        输入：folder = ["/a/b/c","/a/b/d","/a/b/ca"]
        输出：["/a/b/c","/a/b/ca","/a/b/d"]

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem  -->
    <!-- 
        1、将 folder 按字典序进行排序；
        2、依次去对比每一项。 -->
    <script>
        var removeSubfolders = function (folder) {
            folder = folder.sort();
            let result = [];
            const { length } = folder;
            for (let i = 0, j; i < length; i++) {
                j = i + 1;
                let v = `${folder[i]}/`;
                result.push(folder[i]);
                while (j < length) {
                    debugger
                    // 如果不包含，直接中断
                    if (!folder[j].includes(v)) break;
                    j++;
                }
                // 把j-1的值赋给i，后面还会经历一个i++
                i = j - 1;
            }
            return result;
        };
        console.log(removeSubfolders(["/a", "/a/b", "/c/d", "/c/d/e", "/c/f"]));

        // 作者：caoyq0521
        // 链接：https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/solution/shan-chu-zi-wen-jian-jia-by-caoyq0521/


        var removeS2 = (folder) => {
            folder = folder.sort()
            let res = []
            const { length } = folder
            for (let i = 0, j; i < length; i++) {
                j = i + 1
                let v = `${folder[i]}/`
                res.push(folder[i])
                while (j < length) {
                    if (!folder[j].includes(v)) break
                    j++
                }
                i = j - 1
            }
            return res
        }
    </script>
</body>

</html>