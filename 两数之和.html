<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

    你可以按任意顺序返回答案。

     

    示例 1：

    输入：nums = [2,7,11,15], target = 9
    输出：[0,1]
    解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
    示例 2：

    输入：nums = [3,2,4], target = 6
    输出：[1,2]
    示例 3：

    输入：nums = [3,3], target = 6
    输出：[0,1]

    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/two-sum -->

    <!-- 这题就相当于是两个人相亲一样。字典表Map就是媒介所，对每个想要媳妇或者老公的人的信息进行记录，然后来了一个同样想找对象的人就去媒介所（字典表）中查找是否有符合目标值的老公。emm就这样

    思路
    创建媒介所（字典表Map）
    遍历数组，匹配符合信息的目标值 taget - currentValue
    匹配成功返回两个数值下标
    匹配失败就将选手的信息放入媒介所

    作者：callmew
    链接：https://leetcode-cn.com/problems/two-sum/solution/li-yong-javascriptde-mapjiu-xing-qiu-jie-1zyi/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->
  <script>
    var twoSum = function(nums, target) {
      if(!nums) return [];
      // 创建字典表
      const m = new Map();
      // 遍历nums数组
      for(let i = 0; i < nums.length; i++){
        // 获取当前值
        const n = nums[i];
        // 获取对当前与该值匹配的数值
        const n2 = target - nums[i];
        // 判断目标值是否在字典中
        if(m.has(n2)){
          // 是，在返回目标值的坐标和当前数值的坐标
          return [m.get(n2),i]
        }
        // 不在字典中，则放入字典，key为数值，value为下标 Map(key,value),根据一个key查找一个value
        m.set(n,i)
      }
    };

    // 作者：callmew
    // 链接：https://leetcode-cn.com/problems/two-sum/solution/li-yong-javascriptde-mapjiu-xing-qiu-jie-1zyi/


      var twoS2=(nums,target)=>{
        if(!nums)return []
        const m=new Map()
        for(let i=0;i<nums.length;i++){
          const n=nums[i]
          const n2=target - nums[i]
          if(m.has(n2)){
            return [m.get(n2),i]
          }
          m.set(n,i)
        }
      }

      var twoS3=(nums,target)=>{
        if(!nums)return []
        const m=new Map()
        for(let i=0;i<nums.length;i++){
          const n=nums[i]
          const n2=target-nums[i]
          if(m.has(n2)){
            return [m.get(n2),i]
          }
          m.set(n,i)
        }
      }
  </script>
</body>
</html>