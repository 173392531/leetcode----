<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。
        求按从小到大的顺序的第 n 个丑数。

        示例:

        输入: n = 10
        输出: 12
        解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/chou-shu-lcof
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->

        <!-- 因为丑数只包含质因数 2, 3, 5，所以对于下个丑数来说，
            一定是前面某个丑数乘 3、乘 4 或者乘 5 所得。
            准备三个指针 ptr2、ptr3、ptr5，它们指向的数只能乘 2、3 和 5。
            在循环过程中，每次选取 2 * res[ptr2]、3 * res[ptr3] 和
            5 * res[ptr5]这三个数中结果最小的数，并且将对应的指针向前移动。
            有效循环是 n 次，当循环结束后，res 数组中就按从小到大的顺序保存了丑数。

    链接：https://leetcode-cn.com/problems/chou-shu-lcof/solution/shuang-jie-fa-dong-tai-gui-hua-zui-xiao-dui-javasc/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->
    <script>
        var nthUglyNumber = function (n) {
            const res = new Array(n);
            res[0] = 1;

            let ptr2 = 0, // 下个数字永远 * 2
                ptr3 = 0, // 下个数字永远 * 3
                ptr5 = 0; // 下个数字永远 * 5

            for (let i = 1; i < n; ++i) {
                res[i] = Math.min(res[ptr2] * 2, res[ptr3] * 3, res[ptr5] * 5);
                // 说明前ptr2个丑数*2也不可能产生比i更大的丑数了
                // 所以移动ptr2
                if (res[i] === res[ptr2] * 2) {
                    ++ptr2;
                }
                if (res[i] === res[ptr3] * 3) {
                    ++ptr3;
                }
                if (res[i] === res[ptr5] * 5) {
                    ++ptr5;
                }
            }

            return res[n - 1];
        };

// 作者：xin-tan
// 链接：https://leetcode-cn.com/problems/chou-shu-lcof/solution/shuang-jie-fa-dong-tai-gui-hua-zui-xiao-dui-javasc/

    </script>
</body>

</html>