<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。
        给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，
        在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

        示例1:

        输入：nums = [0, 2, 3, 4, 5]
        输出：0
        说明: 0下标的元素为0
        
        示例2:

        输入：nums = [1, 1, 1]
        输出：1

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/magic-index-lcci
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
    <script>
        const findMagicIndex = (nums) => {
            const find = (lo, hi) => {
                if (lo > hi) return -1;
                const mid = (lo + hi) >>> 1;
                const magicIndex = find(lo, mid - 1);
                if (magicIndex > -1) {
                    return magicIndex;
                } else if (nums[mid] == mid) {
                    return mid;
                } else {
                    return find(mid + 1, hi);
                }
            };
            return find(0, nums.length - 1);
        };

        // 作者：xiao_ben_zhu
        // 链接：https://leetcode-cn.com/problems/magic-index-lcci/solution/shou-hua-tu-jie-er-fen-cha-zhao-de-bian-chong-xia-/

        // 如果左侧找到了魔术索引，就没必要递归找右侧，因为左侧的索引肯定较小。
        // 我们可以根据左侧递归的返回值，决定要不要递归右侧。
        // 让递归函数返回找到的魔术索引，找不到则返回 -1。
        // 先递归找 mid 左侧，找到就返回，没找到，再看 mid 是不是魔术索引，
        // 是就返回，不是才找右侧。时间复杂度最坏去到 O(n)。

        const finI = function (nums) {
            const find = function (l, r) {
                if (l > r) return -1
                const mid = (l + r) >>> 1
                const magicI = find(l, mid - 1);
                if (magicI > -1) {
                    return magicI
                } else if (nums[mid] == mid) {
                    return mid
                } else {
                    return find(mid + 1, r)
                }
            }
            return find(0, nums.length - 1);
        }

        const finI = (nums) => {
            const find = function (l, r) {
                if (l > r) return -1
                const mid = Math.floor((l + r) / 2)
                const magic = find(l, mid - 1)
                if (magic > -1) {
                    return magic
                } else if (nums[mid] == mid) {
                    return mid
                } else {
                    return find(mid + 1, r)
                }
            }
            return find(0, nums.length - 1)
        }

        const find2 = (nums) => {
            const find = (l, r) => {
                if (l > r) return -1
                const mid = Math.floor((l + r) / 2)
                const magic = find(l, mid - 1)
                if (magic > -1) {
                    return magic
                } else if (nums[mid] == mid) {
                    return mid
                } else {
                    return find(0, nums.length - 1)
                }
            }
            return find(0, nums.length - 1)
        }

        // 09-02复习
    </script>
</body>

</html>