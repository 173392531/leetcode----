<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!--有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。
        每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。
        给你两个整数 steps 和 arrLen ，请你计算并返回：
        在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。
        由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

         
        示例 1：

        输入：steps = 3, arrLen = 2
        输出：4
        解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
        向右，向左，不动
        不动，向右，向左
        向右，不动，向左
        不动，不动，不动

        示例  2：

        输入：steps = 2, arrLen = 4
        输出：2
        解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。
        向右，向左
        不动，不动

        示例 3：

        输入：steps = 4, arrLen = 2
        输出：8

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps  -->
    <script>

        var numWays = function (steps, arrLen) {
            let mod = 10 ** 9 + 7
            // 因为要返回原点，所以步骤要除二
            let m = Math.min((steps / 2 | 0) + 1, arrLen)
            let dp = Array(steps + 1).fill(0).map(() => Array(m).fill(0))
            dp[0][0] = 1
            for (let i = 1; i <= steps; i++) {
                for (let j = 0; j < m; j++) {
                    let left = j > 0 ? dp[i - 1][j - 1] : 0
                    let right = j < m - 1 ? dp[i - 1][j + 1] : 0
                    let cur = dp[i - 1][j]
                    dp[i][j] = (left + cur + right) % mod
                }
            }
            return dp[steps][0]
        };

        // 作者：shetia
        // 链接：https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/solution/ting-zai-yuan-di-de-fang-an-shu-by-sheti-sxga/

        
        // dp[i][j] 表示经过 i 步之后, 停在 j 处的方案数

        var numW2 = (steps, arrLen) => {
            let mod = 10 ** 9 + 7
            let m = Math.min((step / 2 | 0) + 1, arrLen)
            let dp = Array(steps + 1).fill(0).map(() => Array(m).fill(0))
            dp[0][0] = 1
            for (let i = 1; i <= steps; i++) {
                for (let j = 0; j < m; j++) {
                    let left = j > 0 ? dp[i - 1][j - 1] : 0
                    let right = j < m - 1 ? dp[i - 1][j + 1] : 0
                    let cur = dp[i - 1][j]
                    dp[i][j] = (left + cur + right) % mod
                }
            }
            return dp[steps][0]
        }

        var numW3 = (steps, arrLen) => {
            let mod = 10 ** 9 + 7
            let m = Math.min((step / 2 | 0) + 1, arrLen)
            let dp = Array(steps + 1).fill(0).map(() => Array(m).fill(0))
            dp[0][0] = 1
            for (let i = 1; i <= steps; i++) {
                for (let j = 0; j < m; j++) {
                    let left = j > 0 ? dp[i - 1][j - 1] : 0
                    let right = j < m - 1 ? dp[i - 1][j + 1] : 0
                    let cur = dp[i - 1][j]
                    dp[i][j] = (left + cur + right) % mod
                }
            }
            return dp[steps][0]
        }

        var numW4=(steps,arrLen)=>{
            let m=Math.min((step/2 | 0)+1,arrLen)
            let dp=Array(step+1).fill(0).map(()=>Array(m).fill(0))
            dp[0][0]=1
            for(let i=1;i<=steps;i++){
                for(let j=0;j<m;j++){
                    let left=j>0?dp[i-1][j-1]:0
                    let right=j<m-1?dp[i-1][j+1]:0
                    let cur=dp[i-1][j]
                    dp[i][j]=(left+cur+right)%mod
                }
            }
            return dp[steps][0]
        }

        var newWay=(steps,arrLen)=>{
            let m=Math.min((steps/2 | 0)+1,arrLen)
            const dp=new Array(steps+1).fill(0).map(_=>new Array(m).fill(0))
            dp[0][0]=1
            for(let i=1;i<=steps;i++){
                for(let j=0;j<m;j++){
                    let left=j>0 ? dp[i-1][j-1]:0
                    let right=j<m-1?dp[i-1][j+1]:0
                    let cur=dp[i-1][j]
                    dp[i][j]=(left+right+cur)
                }
            }
            console.log(dp)
            
            return dp[steps][0]
        }
        console.log(newWay(4,2));
        
    </script>
</body>

</html>