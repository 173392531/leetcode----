<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

        示例 1：

        输入：nums = [1,2,3]
        输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
        示例 2：

        输入：nums = [0,1]
        输出：[[0,1],[1,0]]
        示例 3：

        输入：nums = [1]
        输出：[[1]]

        来源：力扣（LeetCode）
        链接：https://leetcode-cn.com/problems/permutations
        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
    <script>

        var permute = function (nums) {
            const res = [], path = [];
            backtracking(nums, nums.length, []);
            return res;

            function backtracking(n, k, used) {
                if (path.length === k) {
                    res.push(Array.from(path));
                    return;
                }
                for (let i = 0; i < k; i++) {
                    debugger
                    if (used[i]) continue;
                    path.push(n[i]);
                    used[i] = true; // 同支
                    backtracking(n, k, used);
                    console.log(path)
                    path.pop();
                    used[i] = false;
                    console.log(path)
                }
            }
        };
        console.log(permute([1,2,3]))

        // 作者：carlsun - 2
        // 链接：https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/

        var per2=(nums)=>{
            const res=[],path=[]
            backtracking(nums,nums.length,[])
            return res
            function backtracking(n,k,used){
                if(path.length===k){
                    res.push(Array.from(path))
                    return 
                }
                for(let i=0;i<k;i++){
                    if(used[i])continue
                    path.push(n[i])
                    used[i]=true
                    backtracking(n,k,used)
                    path.pop()
                    used[i]=false
                }
            }
        }

        var pre3=(nums)=>{
            const res=[],path=[]
            back(nums,nums.length,[])
            return res
            function back(n,k,used){
                if(path.length===k){
                    res.push(Array.from(path))
                    return 
                }
                for(let i=0;i<k;i++){
                    if(used[i])continue
                    path.push(n[i])
                    used[i]=true
                    back(n,k,used)
                    path.pop()
                    used[i]=false
                }
            }
        }

        var pre4=(nums)=>{
            let res=[],path=[]
            backtrack(nums,nums.length,[])
            return res
            function backtrack(n,k,used){
                if(path.length===k){
                    res.push(Array.from(path))
                    return
                }
                for(let i=0;i<k;i++){
                    if(used[i])continue
                    path.push(n[i])
                    used[i]=true
                    backtrack(nums,k,used)
                    path.pop()
                    used[i]=false
                }
            }
        }

        //09-04复习

        var reP=(nums)=>{
            const res=[],path=[],used=new Array(nums.length).fill(false)
            dfs(path)
            function dfs(path) {
                if(path.length===nums.length){
                    res.push(Array.from(path))
                    return 
                }
                for(let i=0;i<nums.length;i++){
                    if(used[i])continue
                    path.push(nums[i])
                    used[i]=true
                    dfs(path)
                    path.pop()
                    used[i]=false
                }
            }
            return res
        }
    </script>
</body>

</html>