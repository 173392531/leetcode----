<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
    每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
    例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

    示例 1：

    输入: 2
    输出: 1
    解释: 2 = 1 + 1, 1 × 1 = 1

    示例 2:

    输入: 10
    输出: 36
    解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 -->

  <!-- 状态数组dp[i]表示：数字 i 拆分为至少两个正整数之和的最大乘积。为了方便计算，dp 的长度是 n + 1，值初始化为 1。
显然dp[2]等于 1，外层循环从 3 开始遍历，一直到 n 停止。内层循环 j 从 1 开始遍历，一直到 i 之前停止，
它代表着数字 i 可以拆分成 j + (i - j)。但 j * (i - j)不一定是最大乘积，
因为i-j不一定大于dp[i - j]（数字i-j拆分成整数之和的最大乘积），这里要选择最大的值作为 dp[i] 的结果。 -->
  <script>
    /**
      * @param {number} n
      * @return {number}
      */
    var cuttingRope = function (n) {
      const dp = new Array(n + 1).fill(1);

      for (let i = 3; i <= n; ++i) {
        for (let j = 1; j < i; ++j) {
          dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j]);
        }
      }
      return dp[n];
    };
    console.log(cuttingRope(5));
// 作者：xin-tan
// 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/shuang-jie-fa-dong-tai-gui-hua-tan-xin-fa-fu-zha-2/

// 08-20复习
  </script>
</body>

</html>