<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

    你可以假设数组中无重复元素。

    示例 1:

    输入: [1,3,5,6], 5
    输出: 2
    示例 2:

    输入: [1,3,5,6], 2
    输出: 1
    示例 3:

    输入: [1,3,5,6], 7
    输出: 4
    示例 4:

    输入: [1,3,5,6], 0
    输出: 0

    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/search-insert-position
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 -->
  <script>
    var searchInsert = function (nums, target) {
      const n = nums.length;
      let left = 0, right = n - 1, ans = n;
      while (left <= right) {
        // let mid = ((right - left) >> 1) + left;
        let mid=Math.floor((left+right)/2)
        if (target <= nums[mid]) {
          // 这是个很重要的临界点，决定了插入位置，记录下mid
          ans = mid;
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      return ans;
    };

// 作者：LeetCode-Solution
// 链接：https://leetcode-cn.com/problems/search-insert-position/solution/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/

    // 我的解法：
    // var searchInsert = function(nums, target) {
    //   if(target<nums[0]) return 0
    //   const len =nums.length
    //   var left=0
    //   var right=len-1
    //   if(left==right)return target<=nums[0]?0:1
    //   while(right>=left){
    //     let  mid=Math.floor((left+right)/2)
    //     if(target==nums[mid]) return mid
    //     else if(target>nums[mid]){
    //         if(target<=nums[mid+1])return mid+1
    //       left=mid+1
    //     }else{
    //       right=mid-1
    //     }
    //   }
    //   return right+1
    // };
    // console.log(searchInsert([1,3,5,6],5));
  </script>
</body>

</html>